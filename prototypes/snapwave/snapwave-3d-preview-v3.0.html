<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K1 Lightwave // ORGANIC PHYSICS ENGINE</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'JetBrains Mono', monospace; color: #FFB84D; }
        #canvas-container { position: absolute; inset: 0; }
        
        /* Minimal HUD */
        #hud { 
            position: absolute; top: 20px; left: 20px; 
            background: rgba(5,5,8,0.9); 
            padding: 16px; 
            border-left: 2px solid #FFB84D; 
            border-radius: 0px 4px 4px 0px;
            pointer-events: auto;
            backdrop-filter: blur(8px);
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            width: 320px;
        }
        h1 { margin: 0 0 8px 0; font-size: 14px; font-weight: 800; letter-spacing: 0.1em; text-transform: uppercase; color: #E6E9EF; }
        .meta { font-size: 10px; color: #6EE7F3; margin-bottom: 12px; letter-spacing: 0.05em; }
        
        .control { margin-bottom: 12px; }
        .label { display: flex; justify-content: space-between; font-size: 10px; color: #8890a0; margin-bottom: 4px; text-transform: uppercase; }
        .value { color: #fff; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: #FFB84D; height: 2px; background: #333; appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 10px; height: 10px; background: #FFB84D; border-radius: 0; }
        
        .divider { height: 1px; background: rgba(255,255,255,0.1); margin: 15px 0; }
    </style>
</head>
<body>
    <div id="hud">
        <h1>K1 Lightwave</h1>
        <div class="meta">ENGINE: GLSL_PHOTON_TRANSPORT</div>
        
        <div class="control">
            <div class="label"><span>Exposure (HDR)</span> <span class="value" id="val-exposure">6.0</span></div>
            <input type="range" id="exposure" min="1.0" max="10.0" step="0.1" value="6.0">
        </div>
        <div class="control">
            <div class="label"><span>Beam Falloff (Height)</span> <span class="value" id="val-falloff">3.5</span></div>
            <input type="range" id="falloff" min="1.0" max="8.0" step="0.1" value="3.5">
        </div>
        <div class="control">
            <div class="label"><span>Lateral Spread (Blur)</span> <span class="value" id="val-spread">0.015</span></div>
            <input type="range" id="spread" min="0.0" max="0.05" step="0.001" value="0.015">
        </div>
        
        <div class="divider"></div>

        <div class="control">
            <div class="label"><span>Oscillation Speed</span> <span class="value" id="val-oscSpeed">1.0</span></div>
            <input type="range" id="oscSpeed" min="0.2" max="4.0" step="0.1" value="1.0">
        </div>
        <div class="control">
            <div class="label"><span>Phase Spread</span> <span class="value" id="val-phase">0.5</span></div>
            <input type="range" id="phase" min="0.1" max="1.5" step="0.05" value="0.5">
        </div>
        <div class="control">
            <div class="label"><span>Snap Force</span> <span class="value" id="val-snap">2.0</span></div>
            <input type="range" id="snap" min="0.5" max="6.0" step="0.1" value="2.0">
        </div>
        <div class="control">
            <div class="label"><span>Snapwave Decay</span> <span class="value" id="val-decay">0.10</span></div>
            <input type="range" id="decay" min="0.01" max="0.3" step="0.01" value="0.10">
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONSTANTS ---
        const NATIVE_RESOLUTION = 160.0;
        const LED_COUNT = 160;
        const LED_STRIDE = 4;
        const STORAGE_KEY = 'k1_snapwave_motion_settings_v1';
        const defaultSettings = {
            exposure: 6.0,
            falloff: 3.5,
            spread: 0.015,
            oscSpeed: 1.0,
            phase: 0.5,
            snap: 2.0,
            decay: 0.10
        };
        const settings = { ...defaultSettings };
        loadSettings();
        
        // --- STATE ---
        const state = {
            leds: new Float32Array(LED_COUNT * LED_STRIDE), 
            chromagram: new Float32Array(12),
            waveform_peak: 0.0,
            time: 0,
            hue_pos: 0.0,
            osc_speed: settings.oscSpeed,
            phase_spread: settings.phase,
            snap_force: settings.snap,
            decay: settings.decay
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); 

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 2, 35);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        renderer.toneMappingExposure = 1.0; 
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = false;

        // --- POST PROCESS ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.5, 0.1);
        composer.addPass(bloomPass);

        // --- THE PHYSICS SHADER ---
        const ledTexture = new THREE.DataTexture(state.leds, LED_COUNT, 1, THREE.RGBAFormat, THREE.FloatType);
        ledTexture.minFilter = THREE.NearestFilter;
        ledTexture.magFilter = THREE.NearestFilter;

        const K1_PHYSICS_SHADER = {
            vertex: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragment: `
                uniform sampler2D uLedState;
                uniform float uResolution;
                uniform float uFalloff;
                uniform float uExposure;
                uniform float uSpread;
                uniform float uBaseLevel;
                
                varying vec2 vUv;

                float gaussian(float x, float sigma) {
                    return exp(-(x * x) / (2.0 * sigma * sigma));
                }

                void main() {
                    float dist = vUv.y;
                    float vertical_beam = exp(-dist * uFalloff);
                    
                    vec3 accumulatedColor = vec3(0.0);
                    float totalWeight = 0.0;
                    float samples = 7.0;
                    float pixelWidth = 1.0 / uResolution;
                    float currentSigma = uSpread * (0.2 + dist * 3.0);

                    for(float i = -samples; i <= samples; i++) {
                        float offset = i * pixelWidth;
                        float weight = gaussian(offset, currentSigma);
                        vec2 sampleUv = vec2(clamp(vUv.x + offset, 0.0, 1.0), 0.5);
                        vec3 ledColor = texture2D(uLedState, sampleUv).rgb;
                        accumulatedColor += ledColor * weight;
                        totalWeight += weight;
                    }
                    
                    vec3 finalColor = accumulatedColor / totalWeight;
                    float hotSpot = smoothstep(0.02, 0.0, dist) * 8.0;
                    vec3 outColor = finalColor * (vertical_beam + uBaseLevel);
                    outColor = outColor * uExposure + (vec3(1.0) * hotSpot * length(finalColor));

                    gl_FragColor = vec4(outColor, 1.0);
                }
            `
        };

        const uniforms = {
            uLedState: { value: ledTexture },
            uResolution: { value: NATIVE_RESOLUTION },
            uFalloff: { value: settings.falloff },
            uExposure: { value: settings.exposure },
            uSpread: { value: settings.spread },
            uBaseLevel: { value: 0.005 }
        };

        const lgpMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: K1_PHYSICS_SHADER.vertex,
            fragmentShader: K1_PHYSICS_SHADER.fragment,
            side: THREE.DoubleSide
        });

        const geometry = new THREE.PlaneGeometry(32, 6); 
        const lgpMesh = new THREE.Mesh(geometry, lgpMaterial);
        lgpMesh.position.y = 3;
        scene.add(lgpMesh);

        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshBasicMaterial({ color: 0x080808 })
        );
        floor.rotation.x = -Math.PI/2;
        scene.add(floor);

        // --- SNAPWAVE LOGIC ---
        function copy_led(dst, src) {
            const d = dst * LED_STRIDE;
            const s = src * LED_STRIDE;
            state.leds[d] = state.leds[s];
            state.leds[d+1] = state.leds[s+1];
            state.leds[d+2] = state.leds[s+2];
            state.leds[d+3] = state.leds[s+3];
        }

        function shift_leds_center_origin() {
            const center = LED_COUNT / 2;
            for (let i = LED_COUNT - 1; i > center; i--) {
                copy_led(i, i - 1);
            }
            for (let i = 0; i < center - 1; i++) {
                copy_led(i, i + 1);
            }
        }

        function place_head(idx, r, g, b) {
            const base = idx * LED_STRIDE;
            state.leds[base] = r;
            state.leds[base+1] = g;
            state.leds[base+2] = b;
            state.leds[base+3] = 1.0;
        }

        function hsv_to_rgb(h, s, v) {
            let r, g, b, i, f, p, q, t;
            h = h % 1;
            if (h < 0) h += 1;
            i = Math.floor(h * 6); f = h * 6 - i;
            p = v * (1 - s); q = v * (1 - f * s); t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r=v; g=t; b=p; break;
                case 1: r=q; g=v; b=p; break;
                case 2: r=p; g=v; b=t; break;
                case 3: r=p; g=q; b=v; break;
                case 4: r=t; g=p; b=v; break;
                case 5: r=v; g=p; b=q; break;
            }
            return [r, g, b];
        }

        function updateSimulation(dt) {
            if (Math.random() > 0.95) {
                const note = [0, 3, 6, 9][Math.floor(Math.random()*4)];
                state.chromagram[note] = 1.0;
            }
            for (let i = 0; i < 12; i++) state.chromagram[i] *= 0.94;
            state.waveform_peak = Math.pow((Math.sin(state.time * 4)+1)/2, 4.0);

            for (let i = 0; i < LED_COUNT * LED_STRIDE; i++) {
                state.leds[i] *= (1.0 - state.decay);
            }

            shift_leds_center_origin();

            let oscillation = 0;
            let millis = state.time * 1000;
            const baseFreq = 0.001 * state.osc_speed;
            const phaseSpread = state.phase_spread;
            for (let i = 0; i < 12; i++) {
                if (state.chromagram[i] > 0.05) {
                    oscillation += state.chromagram[i] * Math.sin(millis * baseFreq * (1.0 + i * phaseSpread));
                }
            }
            oscillation = Math.tanh(oscillation * state.snap_force);

            let center = LED_COUNT/2;
            let pos = Math.floor(center + (oscillation * center * 0.9));
            if (pos < 0) pos = 0; 
            if (pos >= LED_COUNT) pos = LED_COUNT-1;

            state.hue_pos += 0.002;
            let [r,g,b] = hsv_to_rgb(state.hue_pos, 1.0, 1.0);
            place_head(pos, r, g, b);

            const mirror = LED_COUNT - 1 - pos;
            if (mirror !== pos) {
                place_head(mirror, r, g, b);
            }
        }

        // --- LOOP ---
        let lastTime = 0;
        function animate(t) {
            requestAnimationFrame(animate);
            const dt = (t - lastTime) / 1000;
            lastTime = t;
            state.time += dt;

            updateSimulation(dt);
            ledTexture.needsUpdate = true;
            controls.update();
            composer.render();
        }

        // --- UI BINDINGS ---
        initializeUIFromSettings();

        document.getElementById('exposure').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            uniforms.uExposure.value = val;
            settings.exposure = val;
            updateLabel('val-exposure', val, 1);
            saveSettings();
        });

        document.getElementById('falloff').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            uniforms.uFalloff.value = val;
            settings.falloff = val;
            updateLabel('val-falloff', val, 1);
            saveSettings();
        });

        document.getElementById('spread').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            uniforms.uSpread.value = val;
            settings.spread = val;
            updateLabel('val-spread', val, 3);
            saveSettings();
        });

        document.getElementById('oscSpeed').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            state.osc_speed = val;
            settings.oscSpeed = val;
            updateLabel('val-oscSpeed', val, 1);
            saveSettings();
        });

        document.getElementById('phase').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            state.phase_spread = val;
            settings.phase = val;
            updateLabel('val-phase', val, 2);
            saveSettings();
        });

        document.getElementById('snap').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            state.snap_force = val;
            settings.snap = val;
            updateLabel('val-snap', val, 1);
            saveSettings();
        });

        document.getElementById('decay').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            state.decay = val;
            settings.decay = val;
            updateLabel('val-decay', val, 2);
            saveSettings();
        });

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
        });

        animate(0);

        function initializeUIFromSettings() {
            setSliderState('exposure', 'val-exposure', settings.exposure, 1);
            setSliderState('falloff', 'val-falloff', settings.falloff, 1);
            setSliderState('spread', 'val-spread', settings.spread, 3);
            setSliderState('oscSpeed', 'val-oscSpeed', settings.oscSpeed, 1);
            setSliderState('phase', 'val-phase', settings.phase, 2);
            setSliderState('snap', 'val-snap', settings.snap, 1);
            setSliderState('decay', 'val-decay', settings.decay, 2);
        }

        function setSliderState(sliderId, labelId, value, precision) {
            const slider = document.getElementById(sliderId);
            if (slider) slider.value = value;
            updateLabel(labelId, value, precision);
        }

        function updateLabel(labelId, value, precision) {
            const label = document.getElementById(labelId);
            if (label) label.innerText = value.toFixed(precision);
        }

        function loadSettings() {
            if (typeof window === 'undefined' || !window.localStorage) return;
            try {
                const raw = window.localStorage.getItem(STORAGE_KEY);
                if (!raw) return;
                const data = JSON.parse(raw);
                Object.keys(defaultSettings).forEach((key) => {
                    if (typeof data[key] === 'number') {
                        settings[key] = data[key];
                    }
                });
            } catch (err) {
                console.warn('SNAPWAVE settings load failed', err);
            }
        }

        function saveSettings() {
            if (typeof window === 'undefined' || !window.localStorage) return;
            try {
                window.localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
            } catch (err) {
                console.warn('SNAPWAVE settings save failed', err);
            }
        }
    </script>
</body>
</html>
